#!/usr/bin/python

from Aion.data_generation.stimulation.Garfield import Garfield
from Aion.data_generation.reconstruction.Trace import *
from Aion.utils.data import *     # Needed for accessing configuration files
from Aion.utils.graphics import * # Needed for pretty printing
import introspy # Used for analysis of introspy generated databases

import os, sys, glob, shutil, argparse, subprocess, sqlite3

def defineArguments():
    parser = argparse.ArgumentParser(prog="runExperimentI.py", description="A tool implement the stimulation-detection feedback loop using Garfield as stimulation engine.")
    parser.add_argument("-s", "--sdkdir", help="The path to Android SDK", required=True)
    parser.add_argument("-x", "--malwaredir", help="The directory containing the malicious APK's to analyze", required=False, default=".")
    parser.add_argument("-g", "--goodwaredir", help="The directory containing the benign APK's to analyze", required=False, default=".")
    parser.add_argument("-o", "--outdir", help="The directory to save the analyzed APK behavior", required=False, default="./garfield_out")
    parser.add_argument("-i", "--indir", help="The directory containing the JSON traces of APKs (only used when \"analyzeapks\" is set to \"no\")", required=False, default=".")
    parser.add_argument("-f", "--analyzeapks", help="Whether to perform analysis on the retrieved APK's", required=False, default="no", choices=["yes", "no"])
    parser.add_argument("-t", "--analysistime", help="How long to run monkeyrunner (in seconds)", required=False, default=60)
    return parser

def main():
    try:
        argumentParser = defineArguments()
        arguments = argumentParser.parse_args()
        prettyPrint("Welcome to the \"Aion\"'s experiment I")

        # Some sanity checks
        if not os.path.exists(arguments.sdkdir):
             prettyPrint("Unable to locate the Android SDK. Exiting", "error")
             return False
 
        #TODO: while currentAccuracy >= previousAccuracy:
        if arguments.analyzeapks == "yes":
            # Perform analysis as well
            monkeyRunnerPath = arguments.sdkdir + "/tools/monkeyrunner"
            adbPath = arguments.sdkdir + "/platform-tools/adb"

            # Retrieve malware APK's
            malAPKs = glob.glob("%s/*.apk" % arguments.malwaredir)
            if len(malAPKs) < 1:
                prettyPrint("Could not find any malicious APK's under \"%s\"" % arguments.malwaredir, "warning")
            else:
                prettyPrint("Successfully retrieved %s malicious instances from \"%s\"" % (len(malAPKs), arguments.malwaredir))
            # Retrieve goodware APK's
            goodAPKs = glob.glob("%s/*.apk" % arguments.goodwaredir)
            if len(goodAPKs) < 1:
                prettyPrint("Could not find any malicious APK's under \"%s\"" % arguments.goodwaredir, "warning")
            else:
                prettyPrint("Successfully retrieved %s malicious instances from \"%s\"" % (len(goodAPKs), arguments.goodwaredir))

            allAPKs = malAPKs + goodAPKs
            if len(allAPKs) < 1:
                 prettyPrint("Could not find any APK's under \"%s\". Exiting" % arguments.indir, "error")
                 return False

            for path in allAPKs:
                # 1. Statically analyze the APK using androguard
                APKType = "malware" if path in malAPKs else "goodware"
                currentAPK = Garfield(path, APKType)
                if verboseON():
                    prettyPrint("Analyzing APK: \"%s\"" % path, "debug")

                if not currentAPK.analyzeAPK():
                    prettyPrint("Analysis of APK \"%s\" failed. Skipping" % path, "warning")
                    continue
                # 2. Generate Monkeyrunner script
                if not currentAPK.generateRunnerScript(int(arguments.analysistime)):
                    prettyPrint("Generation of \"Monkeyrunner\" script failed. Skipping", "warning")
                    continue
                # 3. Run the generated script
                args = [monkeyRunnerPath, currentAPK.runnerScript]
                subprocess.Popen(args, stderr=subprocess.STDOUT, stdout=subprocess.PIPE).communicate()[0]
                # 4. Download the introspy.db
                #x = raw_input("continue? ")
                args = [adbPath, "pull", "/data/data/%s/databases/introspy.db" % str(currentAPK.APK.package)]
                subprocess.Popen(args, stderr=subprocess.STDOUT, stdout=subprocess.PIPE).communicate()[0]
                # 5. Analyze the downloaded database
                # 5.a. Check that the database exists and is not empty
                if os.path.exists("introspy.db"):
                    if int(os.path.getsize("introspy.db")) == 0:
                        prettyPrint("The database generated by Introspy is empty. Skipping", "warning")
                        continue
                # Last line of defense
                try:
                    db = introspy.DBAnalyzer("introspy.db", "foobar")
                except sqlite3.OperationalError as sql:
                    prettyPrint("The database generated by Introspy is probably empty. Skipping", "warning")
                    continue

                trace = db.get_traced_calls_as_JSON()
                # 6. Write trace to [outdir]
                if not os.path.exists(arguments.outdir):
                    if verboseON():
                        prettyPrint("Directory \"%s\" does not exit. Creating one" % arguments.outdir, "debug")
                    os.mkdir(arguments.outdir)
 
                traceFile = open("%s/%s_%s.json" % (arguments.outdir, currentAPK.APK.package, currentAPK.APKType), "w")
                traceFile.write(trace)
                traceFile.close()
 
                html = introspy.HTMLReportGenerator(db, "foobar")
                html.write_report_to_directory("%s/%s" % (arguments.outdir, currentAPK.APK.package))
            
                prettyPrint("Done analyzing \"%s\"" % currentAPK.APK.package)

        # Load the JSON files as traces before analysis
        jsonDir = arguments.outdir if arguments.analyzeapks == "yes" else arguments.indir
        allJSONFiles = glob.glob("%s/*.json" % jsonDir)
        if len(allJSONFiles) < 1:
            prettyPrint("Unable to retrieve any JSON files from \"%s\". Exiting" % jsonDir, "error")
            return False
        else:
            prettyPrint("Successfully retrieved %s JSON files from \"%s\"" % (len(allJSONFiles), jsonDir))
        # 1. Parse and retrieve comma-separated traces for all traces
        allTraces = loadJSONTraces(allJSONFiles)
        if len(allTraces) != len(allJSONFiles):
            prettyPrint("The number of parsed traces does not match that of JSON files", "warning")
            answer = raw_input("Continue? [Y/n] ")
            if answer.lower() == "n":
                return False
        # 2. Segregate malicious and benign traces
        malwareTraces, goodwareTraces = [], []
        for index in range(len(allTraces)):
            if allJSONFiles[index].lower().find("malware") != -1:
                malwareTraces.append(allTraces[index])
            elif allJSONFiles[index].lower().find("goodware") != -1:
                goodwareTraces.append(allTraces[index])
        # 3. TODO: The Detection part
        # 4. TODO: The feedback part

            
    except Exception as e:
        prettyPrintError(e)
        return False
    
    prettyPrint("Good day to you ^_^")
    return True

if __name__ == "__main__":
    main() 
